import argparse
import sys
import time

from sklearn.model_selection import KFold, StratifiedKFold
from sklearn import linear_model
from sklearn import naive_bayes
from sklearn import svm
from sklearn import multiclass
from sklearn import ensemble

import constants as const
import data_cleaner as dc
import data_reader
import model

ClassifierMap = {
    'MultinomialNB': [naive_bayes.MultinomialNB(), 'MultinomialNB'],
    'BernoulliNB': [naive_bayes.BernoulliNB(), 'BernoulliNB'],
    'SGDC': [linear_model.SGDClassifier(max_iter=1000, tol=1e-3, n_jobs=-1), 'SGDClassifier'],
    'LinearSVC': [svm.LinearSVC(C=1.0, max_iter=2000), 'LinearSVC'],
    'SVM': [svm.SVC(kernel='poly', degree=3, gamma='auto'), 'SVM'],
    'R_Forest': [ensemble.RandomForestClassifier(n_estimators=100), 'RandomForestClassifier'],
}


def main():
    parser = argparse.ArgumentParser(description='Android Malware Classificator')
    parser.add_argument('method', type=str,
                        help='NaiveBayes=MultinomialNB, SGDC=SGDClassifier, LinearSVC=LinearSVC, SVM=SVM')
    parser.add_argument('--type', type=str, default='detection')
    parser.add_argument('-s', type=str, help='Feature subset', default='S6,S7')
    args = parser.parse_args()

    if args.method not in ClassifierMap.keys():
        print("Method ", args.method, " not available.")
        sys.exit(1)

    print('Generate the data set with: ', args.s.split(','))
    filename = data_reader.generate_data(const.BIG_DATA, args.s.split(','))

    # if args.type == 'detection':
    #     # Select data cleaner based on classifier
    #     if args.method == 'MultinomialNB' or args.method == 'BernoulliNB':
    #         print('Bayes cleaner')
    #         cleaner = dc.bayes
    #     else:
    #         print('Linear Classifier cleaner')
    #         cleaner = dc.linear
    # else:
    #     # Select data cleaner based on classifier
    #     if args.method == 'MultinomialNB' or args.method == 'BernoulliNB':
    #         print('Bayes cleaner')
    #         cleaner = dc.bayes_family
    #     else:
    #         print('Linear Classifier cleaner')
    #         cleaner = dc.linear_family

    if args.method == 'MultinomialNB' or args.method == 'BernoulliNB':
        print('Bayes cleaner')
        cleaner = dc.bayes if args.type == 'detection' else dc.bayes_family
    else:
        print('Linear Classifier cleaner')
        cleaner = dc.linear if args.type == 'detection' else dc.linear_family
    X, y = cleaner(filename)

    classifier = ClassifierMap[args.method][0]
    print('Train and evaluation of the model...')
    print(args.method + ' ' + args.s)
    # START Mesure execution time
    start = time.time()
    kfold = KFold(10, True, 1)
    s_kfold = StratifiedKFold(10, True, 1)
    accuracy, precision, recall, fscore, auc = model.validation(X, y, classifier, s_kfold, args.type)
    end = time.time()
    print('Accuracy: ' + repr(accuracy))
    print('Precision: ' + repr(precision))
    print('Recall: ' + repr(recall))
    print('F1 score: ' + repr(fscore))
    print('AUC Score: ' + repr(auc))
    print('Execution Time: ' + timer(start, end))
    print('')
    print('Plotting learning curve...')
    model.plot(X, y, classifier, s_kfold)
    print('Done.')


# def main():
#     print('Generate the data set...')
#     filename = data_reader.generate_data(const.BIG_DATA, ["S2", "S4", "S5", "S6", "S7"])
#     X, y = dc.linear(filename)
#     # X, y = dc.clean_data_linear_family(filename)
#     print('Train and evaluation of the model...')
#     # START Mesure execution time
#     start = time.time()
#     # END Mesure execution time
#     # classifier = svm.LinearSVC(C=10.0, max_iter=7000)
#     classifier = ensemble.RandomForestClassifier(n_estimators=100)
#     kfold = KFold(10, True, 1)
#     accuracy, precision, recall, fscore = model.validation_family(X, y, classifier, kfold)
#     end = time.time()
#     print('Accuracy: ' + repr(accuracy))
#     print('Precision: ' + repr(precision))
#     print('Recall: ' + repr(recall))
#     print('F1 score: ' + repr(fscore))
#     print('Execution Time: ' + timer(start, end))


def timer(start, end):
    hours, rem = divmod(end - start, 3600)
    minutes, seconds = divmod(rem, 60)
    return "{:0>2}:{:0>2}:{:05.2f}".format(int(hours), int(minutes), seconds)


if __name__ == '__main__':
    main()
